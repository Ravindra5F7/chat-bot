from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import logging
import io
import contextlib
import sys
import subprocess
import tempfile
import os
from typing import Optional  # Corrected import for type hinting

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Python Code Execution Service",
    description="A sandboxed service for executing Python code generated by the LLM.",
    version="0.1.0",
)

class CodeExecutionRequest(BaseModel):
    code: str
    timeout: int = 10  # seconds

class CodeExecutionResponse(BaseModel):
    output: str
    error: Optional[str] = None  # Corrected type hint

@app.post("/execute_code", response_model=CodeExecutionResponse)
async def execute_code(request: CodeExecutionRequest):
    """Executes the provided Python code in a sandboxed environment using isolate."""
    code = request.code
    temp_dir = None
    output = ""
    error_output = ""
    execution_error = None

    try:
        # Create a temporary directory for isolate to use as a sandbox
        temp_dir = tempfile.mkdtemp(prefix="isolate_sandbox_")
        box_id = os.path.basename(temp_dir)  # Use the temp dir name as box_id for isolate

        # Initialize the sandbox with isolate
        init_command = ["isolate", "--box-id", box_id, "--init"]
        logger.info(f"Initializing isolate sandbox: {' '.join(init_command)}")
        init_result = subprocess.run(init_command, capture_output=True, text=True, check=False)
        if init_result.returncode != 0:
            raise RuntimeError(f"Isolate init failed: {init_result.stderr}")

        # Write the user's code to a temporary file inside the sandbox's work directory
        code_file_path = os.path.join(temp_dir, "user_code.py")
        with open(code_file_path, "w") as f:
            f.write(code)

        # Command to run the Python code inside the isolate sandbox
        run_command = [
            "isolate", "--box-id", box_id, 
            "--run", 
            "--time=", str(request.timeout), 
            "--mem=102400",
            "--wall-time=", str(request.timeout + 2),
            "--fsize=1024",
            "--processes=1",
            "--cg-mem",
            "--cg-timing",
            "--share-net",
            "--dir=/etc",
            "--dir=/usr",
            "--dir=/lib",
            "--dir=/bin",
            "--dir=/sbin",
            "--dir=/tmp",
            "--no-clean-box",
            "--meta=/tmp/meta.txt",
            "--stdin=/dev/null",
            "--stdout=/tmp/stdout.txt",
            "--stderr=/tmp/stderr.txt",
            "--env=PYTHONIOENCODING=utf-8",
            "--env=PYTHONUNBUFFERED=1",
            "--user=nobody",
            "--group=nogroup",
            "--chroot",
            "--box-id", box_id,
            "--",
            "python3", "user_code.py"
        ]

        logger.info(f"Running code in isolate sandbox: {' '.join(run_command)}")
        run_result = subprocess.run(run_command, capture_output=True, text=True, check=False)

        # Read output and error from the files inside the sandbox
        stdout_cat_command = ["isolate", "--box-id", box_id, "--cat-file", "/tmp/stdout.txt"]
        stderr_cat_command = ["isolate", "--box-id", box_id, "--cat-file", "/tmp/stderr.txt"]

        output_result = subprocess.run(stdout_cat_command, capture_output=True, text=True, check=False)
        error_result = subprocess.run(stderr_cat_command, capture_output=True, text=True, check=False)

        output = output_result.stdout
        error_output = error_result.stdout

        # Check isolate's exit status
        if run_result.returncode != 0:
            execution_error = f"Isolate execution failed with exit code {run_result.returncode}. Isolate stderr: {run_result.stderr}"
            meta_cat_command = ["isolate", "--box-id", box_id, "--cat-file", "/tmp/meta.txt"]
            meta_result = subprocess.run(meta_cat_command, capture_output=True, text=True, check=False)
            if meta_result.returncode == 0:
                execution_error += f"\nIsolate metadata: {meta_result.stdout}"

    except Exception as e:
        execution_error = str(e)
        logger.error(f"Unhandled exception during code execution setup: {execution_error}")
    finally:
        # Clean up the sandbox
        if temp_dir and os.path.exists(temp_dir):
            cleanup_command = ["isolate", "--box-id", box_id, "--cleanup"]
            logger.info(f"Cleaning up isolate sandbox: {' '.join(cleanup_command)}")
            cleanup_result = subprocess.run(cleanup_command, capture_output=True, text=True, check=False)
            if cleanup_result.returncode != 0:
                logger.error(f"Isolate cleanup failed: {cleanup_result.stderr}")

            try:
                if os.path.exists(temp_dir):  
                    import shutil
                    shutil.rmtree(temp_dir)
                    logger.info(f"Force removed temporary directory {temp_dir}")
            except Exception as e:
                logger.error(f"Error force removing temporary directory {temp_dir}: {e}")

    if execution_error or error_output:
        final_error = execution_error if execution_error else error_output
        logger.warning(f"Code execution finished with errors. Output: {output}, Errors: {final_error}")
        return CodeExecutionResponse(output=output, error=final_error)
    
    logger.info(f"Code executed successfully. Output: {output}")
    return CodeExecutionResponse(output=output)

@app.get("/health")
async def health_check():
    return {"status": "ok", "service": "Python Code Execution Service"}